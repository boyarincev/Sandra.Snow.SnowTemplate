---
layout: post
title: Covariance and contrvariance in C#
categories: C#
published: draft
---

В этой статье я бы хотел дать свое объяснение как работает ковариация и контрвариация в C# - мне кажется оно более понятное, чем большинство объяснений, которые я читал.

##Что такое ковариация и контрвариация##

Предположим у нас есть два типа - тип Animal и тип Cat и Cat наследуется от Animal - то есть мы можем Cat безболезненно привести к Animal.

И есть третий тип, который использует типы Cat и Animal, допустим это тип Zoo. Так вот - Zoo является ковариантным, если мы можем Zoo<Cat> привести к Zoo<Animal>.

И является контрвариантным, если мы можем Zoo<Animal> привести к Zoo<Cat>. Я использовал синтаксис обобщения в примере, но вообще - это будет не обязательно обобщение (это может быть и массив) - смысл в том, что один тип использует другие типы.

Классическим является такой пример:

	IEnumerable<string> strCollection = new List<string>() {"string"};
	IEnumerable<object> objectCollection = strCollection;

string - наследуется от object и коллекцию string мы можем привести к коллекции object.

##Как работает ковариация и контрвариация в C# ##

Ковариация и контрвариация в C# неразрывно связана с методами. Давайте представим, что под типом Zoo из примера выше мы подразумеваем метод, а типы Cat и Animal - это типы возвращемого значения или входного параметра - то есть под Zoo<SomeType> (где SomeType - Cat или Animal) мы подразумеваем:

	public SomeType Zoo()
	{

	}

или

	public void Zoo(SomeType param)
	{

	}

Теперь давайте представим, что у нас есть следующий метод:

	public Animal Zoo()
	{
		//someCode...
		return Cat;
	}

Сигнатурой метода определен возвращаемый тип Animal, а мы возвращаем Cat, вот как этот метод будет использоваться:

	Animal someAnimal = Zoo();

Данный код полностью работоспособен - мы можем возвращать из метода, тип производный от заявленного сигнатурой метода и он будет безболезненно приведен к базовому.

Если вы прочитаете определение ковариации выше, то можете заметить, что пример выше - это пример ковариации - у нас есть метод Zoo, который использует в качестве возвращаемого значения тип Animal, но вместо того, чтобы вернуть Animal - мы возвращаем Cat. Можно сказать, что сигнатура метода:

	public Cat Zoo() // так как фактически мы возвращаем Cat
	{

	}

приводится к сигнатуре:

	public Animal Zoo() // так как на самом деле мы продолжаем использовать Animal
	{

	}

или кратко, можно записать так:
	
	Zoo<Animal> = Zoo<Cat> // это не код, просто краткая запись

И вы можете запомнить первое правило: **Ковариация разрешена для возвращаемого значения метода.**

Теперь, другой пример, представьте сигнатуру метода:

	public void Zoo(Animal param)
	{
		
	}

И код его вызова:

	var cat = new Cat();
	Zoo(cat);

Данный код, тоже полностью работоспособен - мы можем передать в качестве параметра производный тип и он безболезненно будет преобразован к базовому.
Это контрвариация - у нас есть тип Zoo, который в качестве параметра использует тип Animal, но вместо Animal мы передаем производный тип, то есть, можно сказать, что сигнатура метода

	public void Zoo(Animal param)
	{
	
	}

приводится к сигнатуре:

	public void Zoo(Cat param) // так как фактически мы передаем тип Cat
	{

	}

или это можно записать так:
	
	Zoo<Cat> = Zoo<Animal> // опять же не код

И запомнить второе правило: **Контрвариация разрешена для параметров метода**

Весь смысл ковариации и контрвариации в C# можно выразить двумя предложениями:

1. Из метода мы можем возвращать производные типы (наследников) от заявленной сигнатуры метода - и это будет ковариация.
2. При вызове метода, мы можем передавать в него производные типы (наследников) от тех, что заявлены сигнатурой метода - и это будет контрвариация.

Оба эти случая, вполне обычные особенности ООП, которыми вы наверняка пользовались в своей практике.

###Ограничения###

Не работает для конкретных классов

Не работает для  значимых типов (только ссылочные преобразования)

###Примеры###

Ковариация и контрвариация в интерфейсах

Массивах

Делегатах