---
layout: post
title: Covariance and contrvariance in C#
categories: C#
published: draft
---

В этой статье я бы хотел дать свое объяснение как работает ковариация и контрвариация в C#.

##Что такое ковариация и контрвариация##

Предположим у нас есть два типа - тип Animal и тип Cat и Cat наследуется от Animal - то есть мы можем Cat безболезненно привести к Animal.

И есть третий тип, который использует типы Cat и Animal, допустим это тип Zoo. Так вот - Zoo является ковариантным, если мы можем `Zoo<Cat>` привести к `Zoo<Animal>`.

И является контрвариантным, если мы можем `Zoo<Animal>` привести к `Zoo<Cat>`. Я использовал синтаксис обобщения в примере, но вообще - это будет не обязательно обобщение - смысл в том, что один тип использует другие типы.

Классическим является такой пример:

	IEnumerable<string> strCollection = new List<string>() {"string"};
	IEnumerable<object> objectCollection = strCollection;

string - наследуется от object и коллекцию string мы можем привести к коллекции object.

##Смысл ковариации и контрвариации в C# ##

Ковариация и контрвариация в C# неразрывно связана с методами. Давайте представим, что под типом Zoo из примера выше мы подразумеваем метод, а типы Cat и Animal - это типы возвращемого значения или входного параметра - то есть под `Zoo<SomeType>` (где SomeType - Cat или Animal) мы подразумеваем:

	public SomeType Zoo()
	{

	}

или

	public void Zoo(SomeType param)
	{

	}

Теперь давайте представим, что у нас есть следующий метод:

	public Animal Zoo()
	{
		//someCode...
		return Cat;
	}

Сигнатурой метода определен возвращаемый тип Animal, а мы возвращаем Cat, вот как этот метод будет использоваться:

	Animal someAnimal = Zoo();

Данный код полностью работоспособен - мы можем возвращать из метода, тип производный от заявленного сигнатурой метода и он будет приведен к базовому.

Мы, фактически, могли бы использовать метод с сигнатурой:

	public Cat Zoo()
	{

	}

Вместо:

	public Animal Zoo()
	{

	}

И не заметили бы этого в вызывающем коде:

	Animal someAnimal = Zoo();

Это и есть ковариация - у нас есть метод Zoo, который использует в качестве возвращаемого значения тип Animal, но вместо него, мы можем использовать метод с возвращаемым значением типа Cat. Можно сказать, что сигнатура метода:

	public Cat Zoo()
	{

	}

приводится к сигнатуре:

	public Animal Zoo()
	{

	}

или можно записать так:

	Zoo<Cat> приводится к Zoo<Animal>, где Cat наследуется от Animal

И вы можете запомнить первое правило: **Ковариация разрешена для возвращаемого значения метода.**

Теперь, другой пример, представьте сигнатуру метода:

	public void Zoo(Animal param)
	{
		
	}

И код его вызова:

	var cat = new Cat();
	Zoo(cat);

Данный код, тоже полностью работоспособен - мы можем передать в качестве параметра производный тип и он безболезненно будет приведен к базовому и метод нормально отработает.

Мы можем вместо сигнатуры:

	public void Zoo(Animal param)
	{
		
	}

использовать сигнатуру:

	public void Zoo(Cat param)
	{
		
	}

Это - контрвариация. У нас есть тип Zoo, который в качестве параметра использует тип Animal, но вместо него мы можем использовать метод Zoo, который в качестве параметра принимает Cat, то есть, можно сказать, что сигнатура метода:

	public void Zoo(Animal param)
	{
	
	}

приводится к сигнатуре:

	public void Zoo(Cat param)
	{

	}

или это можно записать так:
	
	Zoo<Animal> приводится к Zoo<Cat>, где Cat наследуется от Animal

И запомнить второе правило: **Контрвариация разрешена для параметров метода**

Весь смысл ковариации и контрвариации в C# сводится к двум утверждениям:

1. Из метода мы можем возвращать производные типы (наследников) от заявленной сигнатуры метода - и это будет ковариация.
2. При вызове метода, мы можем передавать в него производные типы (наследников) от тех, что заявлены сигнатурой метода - и это будет контрвариация.

Оба эти случая, используют вполне привычное приведение производного класса к родительскому.

##Ковариация и контрвариация в делегатах##

Примеры выше несколько умозрительные, давайте посмотрим на настоящие примеры ко и контрвариации в C# и начнем с делегатов.

Рассмотрим стандартный делегат `Func<out TResult>` - этот делегат используется для методов с сигнатурой:

	TResult SomeMethod()
	{
	
	}

Например, мы могли бы использовать метод ZooAnimal с возвращаемым значением Animal:

	public Animal ZooAnimal()
	{

	}	

Пример использования:

	Func<Animal> animal = ZooAnimal;

В предыдущем разделе мы выяснили, что мы могли бы использовать метод с другим типом возвращаемого значения - производным, давайте попробуем это сделать:

	public Animal ZooAnimal()
	{

	}	

	public Cat ZooCat()
	{

	}

	public void SomeMethod()
	{
		Func<Animal> animalMethod = ZooCat;
	}

Или можно более развернуто:

	Func<Animal> animalMethod = ZooAnimal;
	Func<Cat> catMethod = ZooCat;
	animalMethod = catMethod;

То есть фактически приводим тип Func<Cat> к Func<Animal> - данный тип преобразования типов - пример ковариации.



###Ограничения###

Не работает для конкретных классов

Не работает для  значимых типов (только ссылочные преобразования)

###Примеры###

Ковариация и контрвариация в интерфейсах

Массивах

Делегатах